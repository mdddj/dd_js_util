// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_image.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ImageParams _$ImageParamsFromJson(Map<String, dynamic> json) {
  return _ImageParams.fromJson(json);
}

/// @nodoc
mixin _$ImageParams {
  double? get width => throw _privateConstructorUsedError;
  double? get height => throw _privateConstructorUsedError;
  double? get size => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxFit? get fit => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BorderRadius? get borderRadius => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxShape? get shape => throw _privateConstructorUsedError;
  bool get enableMemoryCache => throw _privateConstructorUsedError;
  String? get heroTag => throw _privateConstructorUsedError;
  bool get isSelected => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  Widget? get errorWidget => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageParamsCopyWith<ImageParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageParamsCopyWith<$Res> {
  factory $ImageParamsCopyWith(
          ImageParams value, $Res Function(ImageParams) then) =
      _$ImageParamsCopyWithImpl<$Res, ImageParams>;
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      Widget? errorWidget});
}

/// @nodoc
class _$ImageParamsCopyWithImpl<$Res, $Val extends ImageParams>
    implements $ImageParamsCopyWith<$Res> {
  _$ImageParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
  }) {
    return _then(_value.copyWith(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageParamsImplCopyWith<$Res> implements $ImageParamsCopyWith<$Res> {
  factory _$$ImageParamsImplCopyWith(_$ImageParamsImpl value, $Res Function(_$ImageParamsImpl) then) =
      __$$ImageParamsImplCopyWithImpl<$Res>;

  @override
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @JsonKey(toJson: null, fromJson: null, includeFromJson: false, includeToJson: false)
      BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      Widget? errorWidget});
}

/// @nodoc
class __$$ImageParamsImplCopyWithImpl<$Res> extends _$ImageParamsCopyWithImpl<$Res, _$ImageParamsImpl>
    implements _$$ImageParamsImplCopyWith<$Res> {
  __$$ImageParamsImplCopyWithImpl(_$ImageParamsImpl _value, $Res Function(_$ImageParamsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
  }) {
    return _then(_$ImageParamsImpl(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageParamsImpl extends _ImageParams {
  const _$ImageParamsImpl(
      {this.width,
      this.height,
      this.size,
      @JsonKey(toJson: null, fromJson: null, includeFromJson: false, includeToJson: false) this.fit,
      @JsonKey(toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.shape,
      this.enableMemoryCache = true,
      this.heroTag,
      this.isSelected = false,
      @JsonKey(toJson: null, fromJson: null, includeFromJson: false, includeToJson: false) this.errorWidget})
      : super._();

  factory _$ImageParamsImpl.fromJson(Map<String, dynamic> json) => _$$ImageParamsImplFromJson(json);

  @override
  final double? width;
  @override
  final double? height;
  @override
  final double? size;
  @override
  @JsonKey(toJson: null, fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BoxFit? fit;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BorderRadius? borderRadius;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BoxShape? shape;
  @override
  @JsonKey()
  final bool enableMemoryCache;
  @override
  final String? heroTag;
  @override
  @JsonKey()
  final bool isSelected;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final Widget? errorWidget;

  @override
  String toString() {
    return 'ImageParams(width: $width, height: $height, size: $size, fit: $fit, borderRadius: $borderRadius, shape: $shape, enableMemoryCache: $enableMemoryCache, heroTag: $heroTag, isSelected: $isSelected, errorWidget: $errorWidget)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageParamsImpl &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.fit, fit) || other.fit == fit) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            (identical(other.enableMemoryCache, enableMemoryCache) ||
                other.enableMemoryCache == enableMemoryCache) &&
            (identical(other.heroTag, heroTag) || other.heroTag == heroTag) &&
            (identical(other.isSelected, isSelected) ||
                other.isSelected == isSelected) &&
            (identical(other.errorWidget, errorWidget) ||
                other.errorWidget == errorWidget));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, width, height, size, fit,
      borderRadius, shape, enableMemoryCache, heroTag, isSelected, errorWidget);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageParamsImplCopyWith<_$ImageParamsImpl> get copyWith =>
      __$$ImageParamsImplCopyWithImpl<_$ImageParamsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageParamsImplToJson(
      this,
    );
  }
}

abstract class _ImageParams extends ImageParams {
  const factory _ImageParams(
      {final double? width,
      final double? height,
      final double? size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false, includeToJson: false) final BoxShape? shape,
      final bool enableMemoryCache,
      final String? heroTag,
      final bool isSelected,
      @JsonKey(toJson: null, fromJson: null, includeFromJson: false, includeToJson: false)
      final Widget? errorWidget}) = _$ImageParamsImpl;
  const _ImageParams._() : super._();

  factory _ImageParams.fromJson(Map<String, dynamic> json) = _$ImageParamsImpl.fromJson;

  @override
  double? get width;
  @override
  double? get height;
  @override
  double? get size;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxFit? get fit;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BorderRadius? get borderRadius;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxShape? get shape;
  @override
  bool get enableMemoryCache;
  @override
  String? get heroTag;
  @override
  bool get isSelected;

  @override
  @JsonKey(toJson: null, fromJson: null, includeFromJson: false, includeToJson: false)
  Widget? get errorWidget;

  @override
  @JsonKey(ignore: true)
  _$$ImageParamsImplCopyWith<_$ImageParamsImpl> get copyWith => throw _privateConstructorUsedError;
}

MyImage _$MyImageFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'network':
      return MyNetworkImage.fromJson(json);
    case 'base64':
      return MyBase64Image.fromJson(json);
    case 'filePath':
      return MyFilePathImage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'MyImage',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$MyImage {
  ImageParams get params => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MyImageCopyWith<MyImage> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyImageCopyWith<$Res> {
  factory $MyImageCopyWith(MyImage value, $Res Function(MyImage) then) =
      _$MyImageCopyWithImpl<$Res, MyImage>;
  @useResult
  $Res call({ImageParams params});

  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class _$MyImageCopyWithImpl<$Res, $Val extends MyImage>
    implements $MyImageCopyWith<$Res> {
  _$MyImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_value.copyWith(
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ImageParamsCopyWith<$Res> get params {
    return $ImageParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MyNetworkImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyNetworkImageImplCopyWith(_$MyNetworkImageImpl value, $Res Function(_$MyNetworkImageImpl) then) =
      __$$MyNetworkImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyNetworkImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyNetworkImageImpl>
    implements _$$MyNetworkImageImplCopyWith<$Res> {
  __$$MyNetworkImageImplCopyWithImpl(_$MyNetworkImageImpl _value, $Res Function(_$MyNetworkImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? params = null,
  }) {
    return _then(_$MyNetworkImageImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyNetworkImageImpl extends MyNetworkImage {
  _$MyNetworkImageImpl({required this.url, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'network',
        super._();

  factory _$MyNetworkImageImpl.fromJson(Map<String, dynamic> json) => _$$MyNetworkImageImplFromJson(json);

  @override
  final String url;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.network(url: $url, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyNetworkImageImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyNetworkImageImplCopyWith<_$MyNetworkImageImpl> get copyWith =>
      __$$MyNetworkImageImplCopyWithImpl<_$MyNetworkImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return network(url, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return network?.call(url, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(url, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return network(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return network?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyNetworkImageImplToJson(
      this,
    );
  }
}

abstract class MyNetworkImage extends MyImage {
  factory MyNetworkImage({required final String url, final ImageParams params}) = _$MyNetworkImageImpl;
  MyNetworkImage._() : super._();

  factory MyNetworkImage.fromJson(Map<String, dynamic> json) = _$MyNetworkImageImpl.fromJson;

  String get url;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyNetworkImageImplCopyWith<_$MyNetworkImageImpl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyBase64ImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyBase64ImageImplCopyWith(_$MyBase64ImageImpl value, $Res Function(_$MyBase64ImageImpl) then) =
      __$$MyBase64ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String base64Code, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyBase64ImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyBase64ImageImpl>
    implements _$$MyBase64ImageImplCopyWith<$Res> {
  __$$MyBase64ImageImplCopyWithImpl(_$MyBase64ImageImpl _value, $Res Function(_$MyBase64ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? base64Code = null,
    Object? params = null,
  }) {
    return _then(_$MyBase64ImageImpl(
      base64Code: null == base64Code
          ? _value.base64Code
          : base64Code // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyBase64ImageImpl extends MyBase64Image {
  _$MyBase64ImageImpl({required this.base64Code, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'base64',
        super._();

  factory _$MyBase64ImageImpl.fromJson(Map<String, dynamic> json) => _$$MyBase64ImageImplFromJson(json);

  @override
  final String base64Code;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.base64(base64Code: $base64Code, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyBase64ImageImpl &&
            (identical(other.base64Code, base64Code) || other.base64Code == base64Code) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, base64Code, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyBase64ImageImplCopyWith<_$MyBase64ImageImpl> get copyWith =>
      __$$MyBase64ImageImplCopyWithImpl<_$MyBase64ImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return base64(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return base64?.call(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(base64Code, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return base64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return base64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyBase64ImageImplToJson(
      this,
    );
  }
}

abstract class MyBase64Image extends MyImage {
  factory MyBase64Image({required final String base64Code, final ImageParams params}) = _$MyBase64ImageImpl;
  MyBase64Image._() : super._();

  factory MyBase64Image.fromJson(Map<String, dynamic> json) = _$MyBase64ImageImpl.fromJson;

  String get base64Code;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyBase64ImageImplCopyWith<_$MyBase64ImageImpl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyFilePathImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyFilePathImageImplCopyWith(_$MyFilePathImageImpl value, $Res Function(_$MyFilePathImageImpl) then) =
      __$$MyFilePathImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String filePath, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyFilePathImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyFilePathImageImpl>
    implements _$$MyFilePathImageImplCopyWith<$Res> {
  __$$MyFilePathImageImplCopyWithImpl(_$MyFilePathImageImpl _value, $Res Function(_$MyFilePathImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? filePath = null,
    Object? params = null,
  }) {
    return _then(_$MyFilePathImageImpl(
      filePath: null == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyFilePathImageImpl extends MyFilePathImage {
  _$MyFilePathImageImpl({required this.filePath, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'filePath',
        super._();

  factory _$MyFilePathImageImpl.fromJson(Map<String, dynamic> json) => _$$MyFilePathImageImplFromJson(json);

  @override
  final String filePath;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.filePath(filePath: $filePath, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyFilePathImageImpl &&
            (identical(other.filePath, filePath) || other.filePath == filePath) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, filePath, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyFilePathImageImplCopyWith<_$MyFilePathImageImpl> get copyWith =>
      __$$MyFilePathImageImplCopyWithImpl<_$MyFilePathImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return filePath(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return filePath?.call(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this.filePath, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyFilePathImageImplToJson(
      this,
    );
  }
}

abstract class MyFilePathImage extends MyImage {
  factory MyFilePathImage({required final String filePath, final ImageParams params}) = _$MyFilePathImageImpl;
  MyFilePathImage._() : super._();

  factory MyFilePathImage.fromJson(Map<String, dynamic> json) = _$MyFilePathImageImpl.fromJson;

  String get filePath;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyFilePathImageImplCopyWith<_$MyFilePathImageImpl> get copyWith => throw _privateConstructorUsedError;
}
