// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_image.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ImageParams _$ImageParamsFromJson(Map<String, dynamic> json) {
  return _ImageParams.fromJson(json);
}

/// @nodoc
mixin _$ImageParams {
  double? get width => throw _privateConstructorUsedError;
  double? get height => throw _privateConstructorUsedError;
  double? get size => throw _privateConstructorUsedError;
  @igFreezedJson
  BoxFit? get fit => throw _privateConstructorUsedError;
  @igFreezedJson
  BorderRadius? get borderRadius => throw _privateConstructorUsedError;
  @igFreezedJson
  BoxShape? get shape => throw _privateConstructorUsedError;
  bool get enableMemoryCache => throw _privateConstructorUsedError;
  String? get heroTag => throw _privateConstructorUsedError;
  bool get isSelected => throw _privateConstructorUsedError;
  @igFreezedJson
  Widget? get errorWidget => throw _privateConstructorUsedError;
  @igFreezedJson
  VoidCallback? get onTap => throw _privateConstructorUsedError;

  @igFreezedJson
  Color? get color => throw _privateConstructorUsedError;

  bool get clearMemoryCacheIfFailed => throw _privateConstructorUsedError;

  bool get gaplessPlayback => throw _privateConstructorUsedError;

  @igFreezedJson
  BlendMode? get colorBlendMode => throw _privateConstructorUsedError; //---net
  double? get scale => throw _privateConstructorUsedError;

  Map<String, String> get headers => throw _privateConstructorUsedError;

  bool get cache => throw _privateConstructorUsedError;

  int get retries => throw _privateConstructorUsedError;

  @igFreezedJson
  Duration? get timeLimit => throw _privateConstructorUsedError;

  @igFreezedJson
  Duration get timeRetry => throw _privateConstructorUsedError;

  @igFreezedJson
  CancellationToken? get cancelToken => throw _privateConstructorUsedError;

  String? get cacheKey => throw _privateConstructorUsedError;

  bool get printError => throw _privateConstructorUsedError;

  bool get cacheRawData => throw _privateConstructorUsedError;

  String? get imageCacheName => throw _privateConstructorUsedError;

  @igFreezedJson
  Duration? get cacheMaxAge => throw _privateConstructorUsedError;

  int? get cacheWidth => throw _privateConstructorUsedError;

  int? get cacheHeight => throw _privateConstructorUsedError;

  double? get compressionRatio => throw _privateConstructorUsedError;

  int? get maxBytes => throw _privateConstructorUsedError; //--- net end
  String? get package => throw _privateConstructorUsedError;

  @igFreezedJson
  AssetBundle? get bundle => throw _privateConstructorUsedError;

  @Doc(message: '自定义完成小部件')
  @igFreezedJson
  CustomCompletedWidget? get customCompletedWidget => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageParamsCopyWith<ImageParams> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageParamsCopyWith<$Res> {
  factory $ImageParamsCopyWith(
          ImageParams value, $Res Function(ImageParams) then) =
      _$ImageParamsCopyWithImpl<$Res, ImageParams>;
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @igFreezedJson BoxFit? fit,
      @igFreezedJson BorderRadius? borderRadius,
      @igFreezedJson BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @igFreezedJson Widget? errorWidget,
      @igFreezedJson VoidCallback? onTap,
      @igFreezedJson Color? color,
      bool clearMemoryCacheIfFailed,
      bool gaplessPlayback,
      @igFreezedJson BlendMode? colorBlendMode,
      double? scale,
      Map<String, String> headers,
      bool cache,
      int retries,
      @igFreezedJson Duration? timeLimit,
      @igFreezedJson Duration timeRetry,
      @igFreezedJson CancellationToken? cancelToken,
      String? cacheKey,
      bool printError,
      bool cacheRawData,
      String? imageCacheName,
      @igFreezedJson Duration? cacheMaxAge,
      int? cacheWidth,
      int? cacheHeight,
      double? compressionRatio,
      int? maxBytes,
      String? package,
      @igFreezedJson AssetBundle? bundle,
      @Doc(message: '自定义完成小部件') @igFreezedJson CustomCompletedWidget? customCompletedWidget});
}

/// @nodoc
class _$ImageParamsCopyWithImpl<$Res, $Val extends ImageParams>
    implements $ImageParamsCopyWith<$Res> {
  _$ImageParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
    Object? onTap = freezed,
    Object? color = freezed,
    Object? clearMemoryCacheIfFailed = null,
    Object? gaplessPlayback = null,
    Object? colorBlendMode = freezed,
    Object? scale = freezed,
    Object? headers = null,
    Object? cache = null,
    Object? retries = null,
    Object? timeLimit = freezed,
    Object? timeRetry = null,
    Object? cancelToken = freezed,
    Object? cacheKey = freezed,
    Object? printError = null,
    Object? cacheRawData = null,
    Object? imageCacheName = freezed,
    Object? cacheMaxAge = freezed,
    Object? cacheWidth = freezed,
    Object? cacheHeight = freezed,
    Object? compressionRatio = freezed,
    Object? maxBytes = freezed,
    Object? package = freezed,
    Object? bundle = freezed,
    Object? customCompletedWidget = freezed,
  }) {
    return _then(_value.copyWith(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
      onTap: freezed == onTap
          ? _value.onTap
          : onTap // ignore: cast_nullable_to_non_nullable
              as VoidCallback?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      clearMemoryCacheIfFailed: null == clearMemoryCacheIfFailed
          ? _value.clearMemoryCacheIfFailed
          : clearMemoryCacheIfFailed // ignore: cast_nullable_to_non_nullable
              as bool,
      gaplessPlayback: null == gaplessPlayback
          ? _value.gaplessPlayback
          : gaplessPlayback // ignore: cast_nullable_to_non_nullable
              as bool,
      colorBlendMode: freezed == colorBlendMode
          ? _value.colorBlendMode
          : colorBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      scale: freezed == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double?,
      headers: null == headers
          ? _value.headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      cache: null == cache
          ? _value.cache
          : cache // ignore: cast_nullable_to_non_nullable
              as bool,
      retries: null == retries
          ? _value.retries
          : retries // ignore: cast_nullable_to_non_nullable
              as int,
      timeLimit: freezed == timeLimit
          ? _value.timeLimit
          : timeLimit // ignore: cast_nullable_to_non_nullable
              as Duration?,
      timeRetry: null == timeRetry
          ? _value.timeRetry
          : timeRetry // ignore: cast_nullable_to_non_nullable
              as Duration,
      cancelToken: freezed == cancelToken
          ? _value.cancelToken
          : cancelToken // ignore: cast_nullable_to_non_nullable
              as CancellationToken?,
      cacheKey: freezed == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String?,
      printError: null == printError
          ? _value.printError
          : printError // ignore: cast_nullable_to_non_nullable
              as bool,
      cacheRawData: null == cacheRawData
          ? _value.cacheRawData
          : cacheRawData // ignore: cast_nullable_to_non_nullable
              as bool,
      imageCacheName: freezed == imageCacheName
          ? _value.imageCacheName
          : imageCacheName // ignore: cast_nullable_to_non_nullable
              as String?,
      cacheMaxAge: freezed == cacheMaxAge
          ? _value.cacheMaxAge
          : cacheMaxAge // ignore: cast_nullable_to_non_nullable
              as Duration?,
      cacheWidth: freezed == cacheWidth
          ? _value.cacheWidth
          : cacheWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      cacheHeight: freezed == cacheHeight
          ? _value.cacheHeight
          : cacheHeight // ignore: cast_nullable_to_non_nullable
              as int?,
      compressionRatio: freezed == compressionRatio
          ? _value.compressionRatio
          : compressionRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      maxBytes: freezed == maxBytes
          ? _value.maxBytes
          : maxBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      package: freezed == package
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as String?,
      bundle: freezed == bundle
          ? _value.bundle
          : bundle // ignore: cast_nullable_to_non_nullable
              as AssetBundle?,
      customCompletedWidget: freezed == customCompletedWidget
          ? _value.customCompletedWidget
          : customCompletedWidget // ignore: cast_nullable_to_non_nullable
              as CustomCompletedWidget?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ImageParamsImplCopyWith<$Res> implements $ImageParamsCopyWith<$Res> {
  factory _$$ImageParamsImplCopyWith(_$ImageParamsImpl value, $Res Function(_$ImageParamsImpl) then) =
      __$$ImageParamsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @igFreezedJson BoxFit? fit,
      @igFreezedJson BorderRadius? borderRadius,
      @igFreezedJson BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @igFreezedJson Widget? errorWidget,
      @igFreezedJson VoidCallback? onTap,
      @igFreezedJson Color? color,
      bool clearMemoryCacheIfFailed,
      bool gaplessPlayback,
      @igFreezedJson BlendMode? colorBlendMode,
      double? scale,
      Map<String, String> headers,
      bool cache,
      int retries,
      @igFreezedJson Duration? timeLimit,
      @igFreezedJson Duration timeRetry,
      @igFreezedJson CancellationToken? cancelToken,
      String? cacheKey,
      bool printError,
      bool cacheRawData,
      String? imageCacheName,
      @igFreezedJson Duration? cacheMaxAge,
      int? cacheWidth,
      int? cacheHeight,
      double? compressionRatio,
      int? maxBytes,
      String? package,
      @igFreezedJson AssetBundle? bundle,
      @Doc(message: '自定义完成小部件') @igFreezedJson CustomCompletedWidget? customCompletedWidget});
}

/// @nodoc
class __$$ImageParamsImplCopyWithImpl<$Res> extends _$ImageParamsCopyWithImpl<$Res, _$ImageParamsImpl>
    implements _$$ImageParamsImplCopyWith<$Res> {
  __$$ImageParamsImplCopyWithImpl(_$ImageParamsImpl _value, $Res Function(_$ImageParamsImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
    Object? onTap = freezed,
    Object? color = freezed,
    Object? clearMemoryCacheIfFailed = null,
    Object? gaplessPlayback = null,
    Object? colorBlendMode = freezed,
    Object? scale = freezed,
    Object? headers = null,
    Object? cache = null,
    Object? retries = null,
    Object? timeLimit = freezed,
    Object? timeRetry = null,
    Object? cancelToken = freezed,
    Object? cacheKey = freezed,
    Object? printError = null,
    Object? cacheRawData = null,
    Object? imageCacheName = freezed,
    Object? cacheMaxAge = freezed,
    Object? cacheWidth = freezed,
    Object? cacheHeight = freezed,
    Object? compressionRatio = freezed,
    Object? maxBytes = freezed,
    Object? package = freezed,
    Object? bundle = freezed,
    Object? customCompletedWidget = freezed,
  }) {
    return _then(_$ImageParamsImpl(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
      onTap: freezed == onTap
          ? _value.onTap
          : onTap // ignore: cast_nullable_to_non_nullable
              as VoidCallback?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as Color?,
      clearMemoryCacheIfFailed: null == clearMemoryCacheIfFailed
          ? _value.clearMemoryCacheIfFailed
          : clearMemoryCacheIfFailed // ignore: cast_nullable_to_non_nullable
              as bool,
      gaplessPlayback: null == gaplessPlayback
          ? _value.gaplessPlayback
          : gaplessPlayback // ignore: cast_nullable_to_non_nullable
              as bool,
      colorBlendMode: freezed == colorBlendMode
          ? _value.colorBlendMode
          : colorBlendMode // ignore: cast_nullable_to_non_nullable
              as BlendMode?,
      scale: freezed == scale
          ? _value.scale
          : scale // ignore: cast_nullable_to_non_nullable
              as double?,
      headers: null == headers
          ? _value._headers
          : headers // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      cache: null == cache
          ? _value.cache
          : cache // ignore: cast_nullable_to_non_nullable
              as bool,
      retries: null == retries
          ? _value.retries
          : retries // ignore: cast_nullable_to_non_nullable
              as int,
      timeLimit: freezed == timeLimit
          ? _value.timeLimit
          : timeLimit // ignore: cast_nullable_to_non_nullable
              as Duration?,
      timeRetry: null == timeRetry
          ? _value.timeRetry
          : timeRetry // ignore: cast_nullable_to_non_nullable
              as Duration,
      cancelToken: freezed == cancelToken
          ? _value.cancelToken
          : cancelToken // ignore: cast_nullable_to_non_nullable
              as CancellationToken?,
      cacheKey: freezed == cacheKey
          ? _value.cacheKey
          : cacheKey // ignore: cast_nullable_to_non_nullable
              as String?,
      printError: null == printError
          ? _value.printError
          : printError // ignore: cast_nullable_to_non_nullable
              as bool,
      cacheRawData: null == cacheRawData
          ? _value.cacheRawData
          : cacheRawData // ignore: cast_nullable_to_non_nullable
              as bool,
      imageCacheName: freezed == imageCacheName
          ? _value.imageCacheName
          : imageCacheName // ignore: cast_nullable_to_non_nullable
              as String?,
      cacheMaxAge: freezed == cacheMaxAge
          ? _value.cacheMaxAge
          : cacheMaxAge // ignore: cast_nullable_to_non_nullable
              as Duration?,
      cacheWidth: freezed == cacheWidth
          ? _value.cacheWidth
          : cacheWidth // ignore: cast_nullable_to_non_nullable
              as int?,
      cacheHeight: freezed == cacheHeight
          ? _value.cacheHeight
          : cacheHeight // ignore: cast_nullable_to_non_nullable
              as int?,
      compressionRatio: freezed == compressionRatio
          ? _value.compressionRatio
          : compressionRatio // ignore: cast_nullable_to_non_nullable
              as double?,
      maxBytes: freezed == maxBytes
          ? _value.maxBytes
          : maxBytes // ignore: cast_nullable_to_non_nullable
              as int?,
      package: freezed == package
          ? _value.package
          : package // ignore: cast_nullable_to_non_nullable
              as String?,
      bundle: freezed == bundle
          ? _value.bundle
          : bundle // ignore: cast_nullable_to_non_nullable
              as AssetBundle?,
      customCompletedWidget: freezed == customCompletedWidget
          ? _value.customCompletedWidget
          : customCompletedWidget // ignore: cast_nullable_to_non_nullable
              as CustomCompletedWidget?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$ImageParamsImpl extends _ImageParams {
  const _$ImageParamsImpl(
      {this.width,
      this.height,
      this.size,
      @igFreezedJson this.fit,
      @igFreezedJson this.borderRadius,
      @igFreezedJson this.shape,
      this.enableMemoryCache = true,
      this.heroTag,
      this.isSelected = false,
      @igFreezedJson this.errorWidget,
      @igFreezedJson this.onTap,
      @igFreezedJson this.color,
      this.clearMemoryCacheIfFailed = true,
      this.gaplessPlayback = true,
      @igFreezedJson this.colorBlendMode,
      this.scale,
      final Map<String, String> headers = const {},
      this.cache = true,
      this.retries = 3,
      @igFreezedJson this.timeLimit,
      @igFreezedJson this.timeRetry = const Duration(seconds: 3),
      @igFreezedJson this.cancelToken,
      this.cacheKey,
      this.printError = false,
      this.cacheRawData = true,
      this.imageCacheName,
      @igFreezedJson this.cacheMaxAge,
      this.cacheWidth,
      this.cacheHeight,
      this.compressionRatio,
      this.maxBytes,
      this.package,
      @igFreezedJson this.bundle,
      @Doc(message: '自定义完成小部件') @igFreezedJson this.customCompletedWidget})
      : _headers = headers,
        super._();

  factory _$ImageParamsImpl.fromJson(Map<String, dynamic> json) => _$$ImageParamsImplFromJson(json);

  @override
  final double? width;
  @override
  final double? height;
  @override
  final double? size;
  @override
  @igFreezedJson
  final BoxFit? fit;
  @override
  @igFreezedJson
  final BorderRadius? borderRadius;
  @override
  @igFreezedJson
  final BoxShape? shape;
  @override
  @JsonKey()
  final bool enableMemoryCache;
  @override
  final String? heroTag;
  @override
  @JsonKey()
  final bool isSelected;
  @override
  @igFreezedJson
  final Widget? errorWidget;
  @override
  @igFreezedJson
  final VoidCallback? onTap;
  @override
  @igFreezedJson
  final Color? color;
  @override
  @JsonKey()
  final bool clearMemoryCacheIfFailed;
  @override
  @JsonKey()
  final bool gaplessPlayback;
  @override
  @igFreezedJson
  final BlendMode? colorBlendMode;

//---net
  @override
  final double? scale;
  final Map<String, String> _headers;

  @override
  @JsonKey()
  Map<String, String> get headers {
    if (_headers is EqualUnmodifiableMapView) return _headers;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_headers);
  }

  @override
  @JsonKey()
  final bool cache;
  @override
  @JsonKey()
  final int retries;
  @override
  @igFreezedJson
  final Duration? timeLimit;
  @override
  @igFreezedJson
  final Duration timeRetry;
  @override
  @igFreezedJson
  final CancellationToken? cancelToken;
  @override
  final String? cacheKey;
  @override
  @JsonKey()
  final bool printError;
  @override
  @JsonKey()
  final bool cacheRawData;
  @override
  final String? imageCacheName;
  @override
  @igFreezedJson
  final Duration? cacheMaxAge;
  @override
  final int? cacheWidth;
  @override
  final int? cacheHeight;
  @override
  final double? compressionRatio;
  @override
  final int? maxBytes;

//--- net end
  @override
  final String? package;
  @override
  @igFreezedJson
  final AssetBundle? bundle;
  @override
  @Doc(message: '自定义完成小部件')
  @igFreezedJson
  final CustomCompletedWidget? customCompletedWidget;

  @override
  String toString() {
    return 'ImageParams(width: $width, height: $height, size: $size, fit: $fit, borderRadius: $borderRadius, shape: $shape, enableMemoryCache: $enableMemoryCache, heroTag: $heroTag, isSelected: $isSelected, errorWidget: $errorWidget, onTap: $onTap, color: $color, clearMemoryCacheIfFailed: $clearMemoryCacheIfFailed, gaplessPlayback: $gaplessPlayback, colorBlendMode: $colorBlendMode, scale: $scale, headers: $headers, cache: $cache, retries: $retries, timeLimit: $timeLimit, timeRetry: $timeRetry, cancelToken: $cancelToken, cacheKey: $cacheKey, printError: $printError, cacheRawData: $cacheRawData, imageCacheName: $imageCacheName, cacheMaxAge: $cacheMaxAge, cacheWidth: $cacheWidth, cacheHeight: $cacheHeight, compressionRatio: $compressionRatio, maxBytes: $maxBytes, package: $package, bundle: $bundle, customCompletedWidget: $customCompletedWidget)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ImageParamsImpl &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.fit, fit) || other.fit == fit) &&
            (identical(other.borderRadius, borderRadius) || other.borderRadius == borderRadius) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            (identical(other.enableMemoryCache, enableMemoryCache) || other.enableMemoryCache == enableMemoryCache) &&
            (identical(other.heroTag, heroTag) || other.heroTag == heroTag) &&
            (identical(other.isSelected, isSelected) || other.isSelected == isSelected) &&
            (identical(other.errorWidget, errorWidget) || other.errorWidget == errorWidget) &&
            (identical(other.onTap, onTap) || other.onTap == onTap) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.clearMemoryCacheIfFailed, clearMemoryCacheIfFailed) ||
                other.clearMemoryCacheIfFailed == clearMemoryCacheIfFailed) &&
            (identical(other.gaplessPlayback, gaplessPlayback) || other.gaplessPlayback == gaplessPlayback) &&
            (identical(other.colorBlendMode, colorBlendMode) || other.colorBlendMode == colorBlendMode) &&
            (identical(other.scale, scale) || other.scale == scale) &&
            const DeepCollectionEquality().equals(other._headers, _headers) &&
            (identical(other.cache, cache) || other.cache == cache) &&
            (identical(other.retries, retries) || other.retries == retries) &&
            (identical(other.timeLimit, timeLimit) || other.timeLimit == timeLimit) &&
            (identical(other.timeRetry, timeRetry) || other.timeRetry == timeRetry) &&
            (identical(other.cancelToken, cancelToken) || other.cancelToken == cancelToken) &&
            (identical(other.cacheKey, cacheKey) || other.cacheKey == cacheKey) &&
            (identical(other.printError, printError) || other.printError == printError) &&
            (identical(other.cacheRawData, cacheRawData) || other.cacheRawData == cacheRawData) &&
            (identical(other.imageCacheName, imageCacheName) || other.imageCacheName == imageCacheName) &&
            (identical(other.cacheMaxAge, cacheMaxAge) || other.cacheMaxAge == cacheMaxAge) &&
            (identical(other.cacheWidth, cacheWidth) || other.cacheWidth == cacheWidth) &&
            (identical(other.cacheHeight, cacheHeight) || other.cacheHeight == cacheHeight) &&
            (identical(other.compressionRatio, compressionRatio) || other.compressionRatio == compressionRatio) &&
            (identical(other.maxBytes, maxBytes) || other.maxBytes == maxBytes) &&
            (identical(other.package, package) || other.package == package) &&
            (identical(other.bundle, bundle) || other.bundle == bundle) &&
            (identical(other.customCompletedWidget, customCompletedWidget) ||
                other.customCompletedWidget == customCompletedWidget));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hashAll([
        runtimeType,
        width,
        height,
        size,
        fit,
        borderRadius,
        shape,
        enableMemoryCache,
        heroTag,
        isSelected,
        errorWidget,
        onTap,
        color,
        clearMemoryCacheIfFailed,
        gaplessPlayback,
        colorBlendMode,
        scale,
        const DeepCollectionEquality().hash(_headers),
        cache,
        retries,
        timeLimit,
        timeRetry,
        cancelToken,
        cacheKey,
        printError,
        cacheRawData,
        imageCacheName,
        cacheMaxAge,
        cacheWidth,
        cacheHeight,
        compressionRatio,
        maxBytes,
        package,
        bundle,
        customCompletedWidget
      ]);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ImageParamsImplCopyWith<_$ImageParamsImpl> get copyWith =>
      __$$ImageParamsImplCopyWithImpl<_$ImageParamsImpl>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$ImageParamsImplToJson(
      this,
    );
  }
}

abstract class _ImageParams extends ImageParams {
  const factory _ImageParams(
      {final double? width,
      final double? height,
      final double? size,
      @igFreezedJson final BoxFit? fit,
      @igFreezedJson final BorderRadius? borderRadius,
      @igFreezedJson final BoxShape? shape,
      final bool enableMemoryCache,
      final String? heroTag,
      final bool isSelected,
      @igFreezedJson final Widget? errorWidget,
      @igFreezedJson final VoidCallback? onTap,
      @igFreezedJson final Color? color,
      final bool clearMemoryCacheIfFailed,
      final bool gaplessPlayback,
      @igFreezedJson final BlendMode? colorBlendMode,
      final double? scale,
      final Map<String, String> headers,
      final bool cache,
      final int retries,
      @igFreezedJson final Duration? timeLimit,
      @igFreezedJson final Duration timeRetry,
      @igFreezedJson final CancellationToken? cancelToken,
      final String? cacheKey,
      final bool printError,
      final bool cacheRawData,
      final String? imageCacheName,
      @igFreezedJson final Duration? cacheMaxAge,
      final int? cacheWidth,
      final int? cacheHeight,
      final double? compressionRatio,
      final int? maxBytes,
      final String? package,
      @igFreezedJson final AssetBundle? bundle,
      @Doc(message: '自定义完成小部件') @igFreezedJson final CustomCompletedWidget? customCompletedWidget}) = _$ImageParamsImpl;
  const _ImageParams._() : super._();

  factory _ImageParams.fromJson(Map<String, dynamic> json) = _$ImageParamsImpl.fromJson;

  @override
  double? get width;
  @override
  double? get height;
  @override
  double? get size;
  @override
  @igFreezedJson
  BoxFit? get fit;
  @override
  @igFreezedJson
  BorderRadius? get borderRadius;
  @override
  @igFreezedJson
  BoxShape? get shape;
  @override
  bool get enableMemoryCache;
  @override
  String? get heroTag;
  @override
  bool get isSelected;
  @override
  @igFreezedJson
  Widget? get errorWidget;
  @override
  @igFreezedJson
  VoidCallback? get onTap;

  @override
  @igFreezedJson
  Color? get color;

  @override
  bool get clearMemoryCacheIfFailed;

  @override
  bool get gaplessPlayback;

  @override
  @igFreezedJson
  BlendMode? get colorBlendMode;

  @override //---net
  double? get scale;

  @override
  Map<String, String> get headers;

  @override
  bool get cache;

  @override
  int get retries;

  @override
  @igFreezedJson
  Duration? get timeLimit;

  @override
  @igFreezedJson
  Duration get timeRetry;

  @override
  @igFreezedJson
  CancellationToken? get cancelToken;

  @override
  String? get cacheKey;

  @override
  bool get printError;

  @override
  bool get cacheRawData;

  @override
  String? get imageCacheName;

  @override
  @igFreezedJson
  Duration? get cacheMaxAge;

  @override
  int? get cacheWidth;

  @override
  int? get cacheHeight;

  @override
  double? get compressionRatio;

  @override
  int? get maxBytes;

  @override //--- net end
  String? get package;

  @override
  @igFreezedJson
  AssetBundle? get bundle;

  @override
  @Doc(message: '自定义完成小部件')
  @igFreezedJson
  CustomCompletedWidget? get customCompletedWidget;
  @override
  @JsonKey(ignore: true)
  _$$ImageParamsImplCopyWith<_$ImageParamsImpl> get copyWith => throw _privateConstructorUsedError;
}

MyImage _$MyImageFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'network':
      return MyNetworkImage.fromJson(json);
    case 'base64':
      return MyBase64Image.fromJson(json);
    case 'filePath':
      return MyFilePathImage.fromJson(json);
    case 'asset':
      return MyAssetImage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'MyImage',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$MyImage {
  ImageParams get params => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
    required TResult Function(String assetPath, ImageParams params) asset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
    TResult? Function(String assetPath, ImageParams params)? asset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    TResult Function(String assetPath, ImageParams params)? asset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
    required TResult Function(MyAssetImage value) asset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
    TResult? Function(MyAssetImage value)? asset,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    TResult Function(MyAssetImage value)? asset,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MyImageCopyWith<MyImage> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyImageCopyWith<$Res> {
  factory $MyImageCopyWith(MyImage value, $Res Function(MyImage) then) =
      _$MyImageCopyWithImpl<$Res, MyImage>;
  @useResult
  $Res call({ImageParams params});

  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class _$MyImageCopyWithImpl<$Res, $Val extends MyImage>
    implements $MyImageCopyWith<$Res> {
  _$MyImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_value.copyWith(
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ImageParamsCopyWith<$Res> get params {
    return $ImageParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MyNetworkImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyNetworkImageImplCopyWith(_$MyNetworkImageImpl value, $Res Function(_$MyNetworkImageImpl) then) =
      __$$MyNetworkImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyNetworkImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyNetworkImageImpl>
    implements _$$MyNetworkImageImplCopyWith<$Res> {
  __$$MyNetworkImageImplCopyWithImpl(_$MyNetworkImageImpl _value, $Res Function(_$MyNetworkImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? params = null,
  }) {
    return _then(_$MyNetworkImageImpl(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyNetworkImageImpl extends MyNetworkImage {
  _$MyNetworkImageImpl({required this.url, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'network',
        super._();

  factory _$MyNetworkImageImpl.fromJson(Map<String, dynamic> json) => _$$MyNetworkImageImplFromJson(json);

  @override
  final String url;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.network(url: $url, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyNetworkImageImpl &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyNetworkImageImplCopyWith<_$MyNetworkImageImpl> get copyWith =>
      __$$MyNetworkImageImplCopyWithImpl<_$MyNetworkImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
    required TResult Function(String assetPath, ImageParams params) asset,
  }) {
    return network(url, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
    TResult? Function(String assetPath, ImageParams params)? asset,
  }) {
    return network?.call(url, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    TResult Function(String assetPath, ImageParams params)? asset,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(url, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
    required TResult Function(MyAssetImage value) asset,
  }) {
    return network(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
    TResult? Function(MyAssetImage value)? asset,
  }) {
    return network?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    TResult Function(MyAssetImage value)? asset,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyNetworkImageImplToJson(
      this,
    );
  }
}

abstract class MyNetworkImage extends MyImage {
  factory MyNetworkImage({required final String url, final ImageParams params}) = _$MyNetworkImageImpl;
  MyNetworkImage._() : super._();

  factory MyNetworkImage.fromJson(Map<String, dynamic> json) = _$MyNetworkImageImpl.fromJson;

  String get url;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyNetworkImageImplCopyWith<_$MyNetworkImageImpl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyBase64ImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyBase64ImageImplCopyWith(_$MyBase64ImageImpl value, $Res Function(_$MyBase64ImageImpl) then) =
      __$$MyBase64ImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String base64Code, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyBase64ImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyBase64ImageImpl>
    implements _$$MyBase64ImageImplCopyWith<$Res> {
  __$$MyBase64ImageImplCopyWithImpl(_$MyBase64ImageImpl _value, $Res Function(_$MyBase64ImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? base64Code = null,
    Object? params = null,
  }) {
    return _then(_$MyBase64ImageImpl(
      base64Code: null == base64Code
          ? _value.base64Code
          : base64Code // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyBase64ImageImpl extends MyBase64Image {
  _$MyBase64ImageImpl({required this.base64Code, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'base64',
        super._();

  factory _$MyBase64ImageImpl.fromJson(Map<String, dynamic> json) => _$$MyBase64ImageImplFromJson(json);

  @override
  final String base64Code;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.base64(base64Code: $base64Code, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyBase64ImageImpl &&
            (identical(other.base64Code, base64Code) || other.base64Code == base64Code) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, base64Code, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyBase64ImageImplCopyWith<_$MyBase64ImageImpl> get copyWith =>
      __$$MyBase64ImageImplCopyWithImpl<_$MyBase64ImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
    required TResult Function(String assetPath, ImageParams params) asset,
  }) {
    return base64(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
    TResult? Function(String assetPath, ImageParams params)? asset,
  }) {
    return base64?.call(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    TResult Function(String assetPath, ImageParams params)? asset,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(base64Code, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
    required TResult Function(MyAssetImage value) asset,
  }) {
    return base64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
    TResult? Function(MyAssetImage value)? asset,
  }) {
    return base64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    TResult Function(MyAssetImage value)? asset,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyBase64ImageImplToJson(
      this,
    );
  }
}

abstract class MyBase64Image extends MyImage {
  factory MyBase64Image({required final String base64Code, final ImageParams params}) = _$MyBase64ImageImpl;
  MyBase64Image._() : super._();

  factory MyBase64Image.fromJson(Map<String, dynamic> json) = _$MyBase64ImageImpl.fromJson;

  String get base64Code;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyBase64ImageImplCopyWith<_$MyBase64ImageImpl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyFilePathImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyFilePathImageImplCopyWith(_$MyFilePathImageImpl value, $Res Function(_$MyFilePathImageImpl) then) =
      __$$MyFilePathImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String filePath, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyFilePathImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyFilePathImageImpl>
    implements _$$MyFilePathImageImplCopyWith<$Res> {
  __$$MyFilePathImageImplCopyWithImpl(_$MyFilePathImageImpl _value, $Res Function(_$MyFilePathImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? filePath = null,
    Object? params = null,
  }) {
    return _then(_$MyFilePathImageImpl(
      filePath: null == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyFilePathImageImpl extends MyFilePathImage {
  _$MyFilePathImageImpl({required this.filePath, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'filePath',
        super._();

  factory _$MyFilePathImageImpl.fromJson(Map<String, dynamic> json) => _$$MyFilePathImageImplFromJson(json);

  @override
  final String filePath;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.filePath(filePath: $filePath, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyFilePathImageImpl &&
            (identical(other.filePath, filePath) || other.filePath == filePath) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, filePath, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyFilePathImageImplCopyWith<_$MyFilePathImageImpl> get copyWith =>
      __$$MyFilePathImageImplCopyWithImpl<_$MyFilePathImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
    required TResult Function(String assetPath, ImageParams params) asset,
  }) {
    return filePath(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
    TResult? Function(String assetPath, ImageParams params)? asset,
  }) {
    return filePath?.call(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    TResult Function(String assetPath, ImageParams params)? asset,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this.filePath, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
    required TResult Function(MyAssetImage value) asset,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
    TResult? Function(MyAssetImage value)? asset,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    TResult Function(MyAssetImage value)? asset,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyFilePathImageImplToJson(
      this,
    );
  }
}

abstract class MyFilePathImage extends MyImage {
  factory MyFilePathImage({required final String filePath, final ImageParams params}) = _$MyFilePathImageImpl;
  MyFilePathImage._() : super._();

  factory MyFilePathImage.fromJson(Map<String, dynamic> json) = _$MyFilePathImageImpl.fromJson;

  String get filePath;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyFilePathImageImplCopyWith<_$MyFilePathImageImpl> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyAssetImageImplCopyWith<$Res> implements $MyImageCopyWith<$Res> {
  factory _$$MyAssetImageImplCopyWith(_$MyAssetImageImpl value, $Res Function(_$MyAssetImageImpl) then) =
      __$$MyAssetImageImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String assetPath, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyAssetImageImplCopyWithImpl<$Res> extends _$MyImageCopyWithImpl<$Res, _$MyAssetImageImpl>
    implements _$$MyAssetImageImplCopyWith<$Res> {
  __$$MyAssetImageImplCopyWithImpl(_$MyAssetImageImpl _value, $Res Function(_$MyAssetImageImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? assetPath = null,
    Object? params = null,
  }) {
    return _then(_$MyAssetImageImpl(
      assetPath: null == assetPath
          ? _value.assetPath
          : assetPath // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyAssetImageImpl extends MyAssetImage {
  _$MyAssetImageImpl({required this.assetPath, this.params = const ImageParams(), final String? $type})
      : $type = $type ?? 'asset',
        super._();

  factory _$MyAssetImageImpl.fromJson(Map<String, dynamic> json) => _$$MyAssetImageImplFromJson(json);

  @override
  final String assetPath;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.asset(assetPath: $assetPath, params: $params)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyAssetImageImpl &&
            (identical(other.assetPath, assetPath) || other.assetPath == assetPath) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, assetPath, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyAssetImageImplCopyWith<_$MyAssetImageImpl> get copyWith =>
      __$$MyAssetImageImplCopyWithImpl<_$MyAssetImageImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
    required TResult Function(String assetPath, ImageParams params) asset,
  }) {
    return asset(assetPath, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
    TResult? Function(String assetPath, ImageParams params)? asset,
  }) {
    return asset?.call(assetPath, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    TResult Function(String assetPath, ImageParams params)? asset,
    required TResult orElse(),
  }) {
    if (asset != null) {
      return asset(assetPath, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
    required TResult Function(MyAssetImage value) asset,
  }) {
    return asset(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
    TResult? Function(MyAssetImage value)? asset,
  }) {
    return asset?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    TResult Function(MyAssetImage value)? asset,
    required TResult orElse(),
  }) {
    if (asset != null) {
      return asset(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyAssetImageImplToJson(
      this,
    );
  }
}

abstract class MyAssetImage extends MyImage {
  factory MyAssetImage({required final String assetPath, final ImageParams params}) = _$MyAssetImageImpl;
  MyAssetImage._() : super._();

  factory MyAssetImage.fromJson(Map<String, dynamic> json) = _$MyAssetImageImpl.fromJson;

  String get assetPath;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyAssetImageImplCopyWith<_$MyAssetImageImpl> get copyWith => throw _privateConstructorUsedError;
}
