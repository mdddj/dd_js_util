// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_image.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

ImageParams _$ImageParamsFromJson(Map<String, dynamic> json) {
  return _ImageParams.fromJson(json);
}

/// @nodoc
mixin _$ImageParams {
  double? get width => throw _privateConstructorUsedError;
  double? get height => throw _privateConstructorUsedError;
  double? get size => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxFit? get fit => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BorderRadius? get borderRadius => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxShape? get shape => throw _privateConstructorUsedError;
  bool get enableMemoryCache => throw _privateConstructorUsedError;
  String? get heroTag => throw _privateConstructorUsedError;
  bool get isSelected => throw _privateConstructorUsedError;
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  Widget? get errorWidget => throw _privateConstructorUsedError;

  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ImageParamsCopyWith<ImageParams> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ImageParamsCopyWith<$Res> {
  factory $ImageParamsCopyWith(
          ImageParams value, $Res Function(ImageParams) then) =
      _$ImageParamsCopyWithImpl<$Res, ImageParams>;
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      Widget? errorWidget});
}

/// @nodoc
class _$ImageParamsCopyWithImpl<$Res, $Val extends ImageParams>
    implements $ImageParamsCopyWith<$Res> {
  _$ImageParamsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
  }) {
    return _then(_value.copyWith(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$_ImageParamsCopyWith<$Res>
    implements $ImageParamsCopyWith<$Res> {
  factory _$$_ImageParamsCopyWith(
          _$_ImageParams value, $Res Function(_$_ImageParams) then) =
      __$$_ImageParamsCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {double? width,
      double? height,
      double? size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      BoxShape? shape,
      bool enableMemoryCache,
      String? heroTag,
      bool isSelected,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      Widget? errorWidget});
}

/// @nodoc
class __$$_ImageParamsCopyWithImpl<$Res>
    extends _$ImageParamsCopyWithImpl<$Res, _$_ImageParams>
    implements _$$_ImageParamsCopyWith<$Res> {
  __$$_ImageParamsCopyWithImpl(
      _$_ImageParams _value, $Res Function(_$_ImageParams) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? width = freezed,
    Object? height = freezed,
    Object? size = freezed,
    Object? fit = freezed,
    Object? borderRadius = freezed,
    Object? shape = freezed,
    Object? enableMemoryCache = null,
    Object? heroTag = freezed,
    Object? isSelected = null,
    Object? errorWidget = freezed,
  }) {
    return _then(_$_ImageParams(
      width: freezed == width
          ? _value.width
          : width // ignore: cast_nullable_to_non_nullable
              as double?,
      height: freezed == height
          ? _value.height
          : height // ignore: cast_nullable_to_non_nullable
              as double?,
      size: freezed == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as double?,
      fit: freezed == fit
          ? _value.fit
          : fit // ignore: cast_nullable_to_non_nullable
              as BoxFit?,
      borderRadius: freezed == borderRadius
          ? _value.borderRadius
          : borderRadius // ignore: cast_nullable_to_non_nullable
              as BorderRadius?,
      shape: freezed == shape
          ? _value.shape
          : shape // ignore: cast_nullable_to_non_nullable
              as BoxShape?,
      enableMemoryCache: null == enableMemoryCache
          ? _value.enableMemoryCache
          : enableMemoryCache // ignore: cast_nullable_to_non_nullable
              as bool,
      heroTag: freezed == heroTag
          ? _value.heroTag
          : heroTag // ignore: cast_nullable_to_non_nullable
              as String?,
      isSelected: null == isSelected
          ? _value.isSelected
          : isSelected // ignore: cast_nullable_to_non_nullable
              as bool,
      errorWidget: freezed == errorWidget
          ? _value.errorWidget
          : errorWidget // ignore: cast_nullable_to_non_nullable
              as Widget?,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$_ImageParams extends _ImageParams {
  const _$_ImageParams(
      {this.width,
      this.height,
      this.size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.shape,
      this.enableMemoryCache = true,
      this.heroTag,
      this.isSelected = false,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      this.errorWidget})
      : super._();

  factory _$_ImageParams.fromJson(Map<String, dynamic> json) =>
      _$$_ImageParamsFromJson(json);

  @override
  final double? width;
  @override
  final double? height;
  @override
  final double? size;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BoxFit? fit;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BorderRadius? borderRadius;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final BoxShape? shape;
  @override
  @JsonKey()
  final bool enableMemoryCache;
  @override
  final String? heroTag;
  @override
  @JsonKey()
  final bool isSelected;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  final Widget? errorWidget;

  @override
  String toString() {
    return 'ImageParams(width: $width, height: $height, size: $size, fit: $fit, borderRadius: $borderRadius, shape: $shape, enableMemoryCache: $enableMemoryCache, heroTag: $heroTag, isSelected: $isSelected, errorWidget: $errorWidget)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$_ImageParams &&
            (identical(other.width, width) || other.width == width) &&
            (identical(other.height, height) || other.height == height) &&
            (identical(other.size, size) || other.size == size) &&
            (identical(other.fit, fit) || other.fit == fit) &&
            (identical(other.borderRadius, borderRadius) ||
                other.borderRadius == borderRadius) &&
            (identical(other.shape, shape) || other.shape == shape) &&
            (identical(other.enableMemoryCache, enableMemoryCache) ||
                other.enableMemoryCache == enableMemoryCache) &&
            (identical(other.heroTag, heroTag) || other.heroTag == heroTag) &&
            (identical(other.isSelected, isSelected) ||
                other.isSelected == isSelected) &&
            (identical(other.errorWidget, errorWidget) ||
                other.errorWidget == errorWidget));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, width, height, size, fit,
      borderRadius, shape, enableMemoryCache, heroTag, isSelected, errorWidget);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$_ImageParamsCopyWith<_$_ImageParams> get copyWith =>
      __$$_ImageParamsCopyWithImpl<_$_ImageParams>(this, _$identity);

  @override
  Map<String, dynamic> toJson() {
    return _$$_ImageParamsToJson(
      this,
    );
  }
}

abstract class _ImageParams extends ImageParams {
  const factory _ImageParams(
      {final double? width,
      final double? height,
      final double? size,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final BoxFit? fit,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final BorderRadius? borderRadius,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final BoxShape? shape,
      final bool enableMemoryCache,
      final String? heroTag,
      final bool isSelected,
      @JsonKey(
          toJson: null,
          fromJson: null,
          includeFromJson: false,
          includeToJson: false)
      final Widget? errorWidget}) = _$_ImageParams;
  const _ImageParams._() : super._();

  factory _ImageParams.fromJson(Map<String, dynamic> json) =
      _$_ImageParams.fromJson;

  @override
  double? get width;
  @override
  double? get height;
  @override
  double? get size;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxFit? get fit;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BorderRadius? get borderRadius;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  BoxShape? get shape;
  @override
  bool get enableMemoryCache;
  @override
  String? get heroTag;
  @override
  bool get isSelected;
  @override
  @JsonKey(
      toJson: null,
      fromJson: null,
      includeFromJson: false,
      includeToJson: false)
  Widget? get errorWidget;
  @override
  @JsonKey(ignore: true)
  _$$_ImageParamsCopyWith<_$_ImageParams> get copyWith =>
      throw _privateConstructorUsedError;
}

MyImage _$MyImageFromJson(Map<String, dynamic> json) {
  switch (json['runtimeType']) {
    case 'network':
      return MyNetworkImage.fromJson(json);
    case 'base64':
      return MyBase64Image.fromJson(json);
    case 'filePath':
      return MyFilePathImage.fromJson(json);

    default:
      throw CheckedFromJsonException(json, 'runtimeType', 'MyImage',
          'Invalid union type "${json['runtimeType']}"!');
  }
}

/// @nodoc
mixin _$MyImage {
  ImageParams get params => throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  Map<String, dynamic> toJson() => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $MyImageCopyWith<MyImage> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyImageCopyWith<$Res> {
  factory $MyImageCopyWith(MyImage value, $Res Function(MyImage) then) =
      _$MyImageCopyWithImpl<$Res, MyImage>;
  @useResult
  $Res call({ImageParams params});

  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class _$MyImageCopyWithImpl<$Res, $Val extends MyImage>
    implements $MyImageCopyWith<$Res> {
  _$MyImageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? params = null,
  }) {
    return _then(_value.copyWith(
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ) as $Val);
  }

  @override
  @pragma('vm:prefer-inline')
  $ImageParamsCopyWith<$Res> get params {
    return $ImageParamsCopyWith<$Res>(_value.params, (value) {
      return _then(_value.copyWith(params: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MyNetworkImageCopyWith<$Res>
    implements $MyImageCopyWith<$Res> {
  factory _$$MyNetworkImageCopyWith(
          _$MyNetworkImage value, $Res Function(_$MyNetworkImage) then) =
      __$$MyNetworkImageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String url, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyNetworkImageCopyWithImpl<$Res>
    extends _$MyImageCopyWithImpl<$Res, _$MyNetworkImage>
    implements _$$MyNetworkImageCopyWith<$Res> {
  __$$MyNetworkImageCopyWithImpl(
      _$MyNetworkImage _value, $Res Function(_$MyNetworkImage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? url = null,
    Object? params = null,
  }) {
    return _then(_$MyNetworkImage(
      url: null == url
          ? _value.url
          : url // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyNetworkImage extends MyNetworkImage {
  _$MyNetworkImage(
      {required this.url,
      this.params = const ImageParams(),
      final String? $type})
      : $type = $type ?? 'network',
        super._();

  factory _$MyNetworkImage.fromJson(Map<String, dynamic> json) =>
      _$$MyNetworkImageFromJson(json);

  @override
  final String url;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.network(url: $url, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyNetworkImage &&
            (identical(other.url, url) || other.url == url) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, url, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyNetworkImageCopyWith<_$MyNetworkImage> get copyWith =>
      __$$MyNetworkImageCopyWithImpl<_$MyNetworkImage>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return network(url, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return network?.call(url, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(url, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return network(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return network?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (network != null) {
      return network(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyNetworkImageToJson(
      this,
    );
  }
}

abstract class MyNetworkImage extends MyImage {
  factory MyNetworkImage(
      {required final String url, final ImageParams params}) = _$MyNetworkImage;
  MyNetworkImage._() : super._();

  factory MyNetworkImage.fromJson(Map<String, dynamic> json) =
      _$MyNetworkImage.fromJson;

  String get url;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyNetworkImageCopyWith<_$MyNetworkImage> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyBase64ImageCopyWith<$Res>
    implements $MyImageCopyWith<$Res> {
  factory _$$MyBase64ImageCopyWith(
          _$MyBase64Image value, $Res Function(_$MyBase64Image) then) =
      __$$MyBase64ImageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String base64Code, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyBase64ImageCopyWithImpl<$Res>
    extends _$MyImageCopyWithImpl<$Res, _$MyBase64Image>
    implements _$$MyBase64ImageCopyWith<$Res> {
  __$$MyBase64ImageCopyWithImpl(
      _$MyBase64Image _value, $Res Function(_$MyBase64Image) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? base64Code = null,
    Object? params = null,
  }) {
    return _then(_$MyBase64Image(
      base64Code: null == base64Code
          ? _value.base64Code
          : base64Code // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyBase64Image extends MyBase64Image {
  _$MyBase64Image(
      {required this.base64Code,
      this.params = const ImageParams(),
      final String? $type})
      : $type = $type ?? 'base64',
        super._();

  factory _$MyBase64Image.fromJson(Map<String, dynamic> json) =>
      _$$MyBase64ImageFromJson(json);

  @override
  final String base64Code;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.base64(base64Code: $base64Code, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyBase64Image &&
            (identical(other.base64Code, base64Code) ||
                other.base64Code == base64Code) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, base64Code, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyBase64ImageCopyWith<_$MyBase64Image> get copyWith =>
      __$$MyBase64ImageCopyWithImpl<_$MyBase64Image>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return base64(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return base64?.call(base64Code, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(base64Code, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return base64(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return base64?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (base64 != null) {
      return base64(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyBase64ImageToJson(
      this,
    );
  }
}

abstract class MyBase64Image extends MyImage {
  factory MyBase64Image(
      {required final String base64Code,
      final ImageParams params}) = _$MyBase64Image;
  MyBase64Image._() : super._();

  factory MyBase64Image.fromJson(Map<String, dynamic> json) =
      _$MyBase64Image.fromJson;

  String get base64Code;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyBase64ImageCopyWith<_$MyBase64Image> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$MyFilePathImageCopyWith<$Res>
    implements $MyImageCopyWith<$Res> {
  factory _$$MyFilePathImageCopyWith(
          _$MyFilePathImage value, $Res Function(_$MyFilePathImage) then) =
      __$$MyFilePathImageCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String filePath, ImageParams params});

  @override
  $ImageParamsCopyWith<$Res> get params;
}

/// @nodoc
class __$$MyFilePathImageCopyWithImpl<$Res>
    extends _$MyImageCopyWithImpl<$Res, _$MyFilePathImage>
    implements _$$MyFilePathImageCopyWith<$Res> {
  __$$MyFilePathImageCopyWithImpl(
      _$MyFilePathImage _value, $Res Function(_$MyFilePathImage) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? filePath = null,
    Object? params = null,
  }) {
    return _then(_$MyFilePathImage(
      filePath: null == filePath
          ? _value.filePath
          : filePath // ignore: cast_nullable_to_non_nullable
              as String,
      params: null == params
          ? _value.params
          : params // ignore: cast_nullable_to_non_nullable
              as ImageParams,
    ));
  }
}

/// @nodoc
@JsonSerializable()
class _$MyFilePathImage extends MyFilePathImage {
  _$MyFilePathImage(
      {required this.filePath,
      this.params = const ImageParams(),
      final String? $type})
      : $type = $type ?? 'filePath',
        super._();

  factory _$MyFilePathImage.fromJson(Map<String, dynamic> json) =>
      _$$MyFilePathImageFromJson(json);

  @override
  final String filePath;
  @override
  @JsonKey()
  final ImageParams params;

  @JsonKey(name: 'runtimeType')
  final String $type;

  @override
  String toString() {
    return 'MyImage.filePath(filePath: $filePath, params: $params)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MyFilePathImage &&
            (identical(other.filePath, filePath) ||
                other.filePath == filePath) &&
            (identical(other.params, params) || other.params == params));
  }

  @JsonKey(ignore: true)
  @override
  int get hashCode => Object.hash(runtimeType, filePath, params);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$MyFilePathImageCopyWith<_$MyFilePathImage> get copyWith =>
      __$$MyFilePathImageCopyWithImpl<_$MyFilePathImage>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String url, ImageParams params) network,
    required TResult Function(String base64Code, ImageParams params) base64,
    required TResult Function(String filePath, ImageParams params) filePath,
  }) {
    return filePath(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String url, ImageParams params)? network,
    TResult? Function(String base64Code, ImageParams params)? base64,
    TResult? Function(String filePath, ImageParams params)? filePath,
  }) {
    return filePath?.call(this.filePath, params);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String url, ImageParams params)? network,
    TResult Function(String base64Code, ImageParams params)? base64,
    TResult Function(String filePath, ImageParams params)? filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this.filePath, params);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(MyNetworkImage value) network,
    required TResult Function(MyBase64Image value) base64,
    required TResult Function(MyFilePathImage value) filePath,
  }) {
    return filePath(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(MyNetworkImage value)? network,
    TResult? Function(MyBase64Image value)? base64,
    TResult? Function(MyFilePathImage value)? filePath,
  }) {
    return filePath?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(MyNetworkImage value)? network,
    TResult Function(MyBase64Image value)? base64,
    TResult Function(MyFilePathImage value)? filePath,
    required TResult orElse(),
  }) {
    if (filePath != null) {
      return filePath(this);
    }
    return orElse();
  }

  @override
  Map<String, dynamic> toJson() {
    return _$$MyFilePathImageToJson(
      this,
    );
  }
}

abstract class MyFilePathImage extends MyImage {
  factory MyFilePathImage(
      {required final String filePath,
      final ImageParams params}) = _$MyFilePathImage;
  MyFilePathImage._() : super._();

  factory MyFilePathImage.fromJson(Map<String, dynamic> json) =
      _$MyFilePathImage.fromJson;

  String get filePath;
  @override
  ImageParams get params;
  @override
  @JsonKey(ignore: true)
  _$$MyFilePathImageCopyWith<_$MyFilePathImage> get copyWith =>
      throw _privateConstructorUsedError;
}
