// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'my_platform.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$MyPlatform {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MyPlatformCopyWith<$Res> {
  factory $MyPlatformCopyWith(MyPlatform value, $Res Function(MyPlatform) then) =
      _$MyPlatformCopyWithImpl<$Res, MyPlatform>;
}

/// @nodoc
class _$MyPlatformCopyWithImpl<$Res, $Val extends MyPlatform> implements $MyPlatformCopyWith<$Res> {
  _$MyPlatformCopyWithImpl(this._value, this._then);

// ignore: unused_field
  final $Val _value;
// ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$AndroidPlatformImplCopyWith<$Res> {
  factory _$$AndroidPlatformImplCopyWith(_$AndroidPlatformImpl value, $Res Function(_$AndroidPlatformImpl) then) =
      __$$AndroidPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$AndroidPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$AndroidPlatformImpl>
    implements _$$AndroidPlatformImplCopyWith<$Res> {
  __$$AndroidPlatformImplCopyWithImpl(_$AndroidPlatformImpl _value, $Res Function(_$AndroidPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$AndroidPlatformImpl with DiagnosticableTreeMixin implements AndroidPlatform {
  const _$AndroidPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.android()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.android'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$AndroidPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return android();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return android?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (android != null) {
      return android();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return android(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return android?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (android != null) {
      return android(this);
    }
    return orElse();
  }
}

abstract class AndroidPlatform implements MyPlatform {
  const factory AndroidPlatform() = _$AndroidPlatformImpl;
}

/// @nodoc
abstract class _$$IosPlatformImplCopyWith<$Res> {
  factory _$$IosPlatformImplCopyWith(_$IosPlatformImpl value, $Res Function(_$IosPlatformImpl) then) =
      __$$IosPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$IosPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$IosPlatformImpl>
    implements _$$IosPlatformImplCopyWith<$Res> {
  __$$IosPlatformImplCopyWithImpl(_$IosPlatformImpl _value, $Res Function(_$IosPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$IosPlatformImpl with DiagnosticableTreeMixin implements IosPlatform {
  const _$IosPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.ios()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.ios'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$IosPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return ios();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return ios?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (ios != null) {
      return ios();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return ios(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return ios?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (ios != null) {
      return ios(this);
    }
    return orElse();
  }
}

abstract class IosPlatform implements MyPlatform {
  const factory IosPlatform() = _$IosPlatformImpl;
}

/// @nodoc
abstract class _$$MacosPlatformImplCopyWith<$Res> {
  factory _$$MacosPlatformImplCopyWith(_$MacosPlatformImpl value, $Res Function(_$MacosPlatformImpl) then) =
      __$$MacosPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$MacosPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$MacosPlatformImpl>
    implements _$$MacosPlatformImplCopyWith<$Res> {
  __$$MacosPlatformImplCopyWithImpl(_$MacosPlatformImpl _value, $Res Function(_$MacosPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$MacosPlatformImpl with DiagnosticableTreeMixin implements MacosPlatform {
  const _$MacosPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.macos()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.macos'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$MacosPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return macos();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return macos?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (macos != null) {
      return macos();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return macos(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return macos?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (macos != null) {
      return macos(this);
    }
    return orElse();
  }
}

abstract class MacosPlatform implements MyPlatform {
  const factory MacosPlatform() = _$MacosPlatformImpl;
}

/// @nodoc
abstract class _$$WebPlatformImplCopyWith<$Res> {
  factory _$$WebPlatformImplCopyWith(_$WebPlatformImpl value, $Res Function(_$WebPlatformImpl) then) =
      __$$WebPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WebPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$WebPlatformImpl>
    implements _$$WebPlatformImplCopyWith<$Res> {
  __$$WebPlatformImplCopyWithImpl(_$WebPlatformImpl _value, $Res Function(_$WebPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WebPlatformImpl with DiagnosticableTreeMixin implements WebPlatform {
  const _$WebPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.web()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.web'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$WebPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return web();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return web?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (web != null) {
      return web();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return web(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return web?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (web != null) {
      return web(this);
    }
    return orElse();
  }
}

abstract class WebPlatform implements MyPlatform {
  const factory WebPlatform() = _$WebPlatformImpl;
}

/// @nodoc
abstract class _$$LinuxPlatformImplCopyWith<$Res> {
  factory _$$LinuxPlatformImplCopyWith(_$LinuxPlatformImpl value, $Res Function(_$LinuxPlatformImpl) then) =
      __$$LinuxPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LinuxPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$LinuxPlatformImpl>
    implements _$$LinuxPlatformImplCopyWith<$Res> {
  __$$LinuxPlatformImplCopyWithImpl(_$LinuxPlatformImpl _value, $Res Function(_$LinuxPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LinuxPlatformImpl with DiagnosticableTreeMixin implements LinuxPlatform {
  const _$LinuxPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.linux()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.linux'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$LinuxPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return linux();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return linux?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (linux != null) {
      return linux();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return linux(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return linux?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (linux != null) {
      return linux(this);
    }
    return orElse();
  }
}

abstract class LinuxPlatform implements MyPlatform {
  const factory LinuxPlatform() = _$LinuxPlatformImpl;
}

/// @nodoc
abstract class _$$WindowsPlatformImplCopyWith<$Res> {
  factory _$$WindowsPlatformImplCopyWith(_$WindowsPlatformImpl value, $Res Function(_$WindowsPlatformImpl) then) =
      __$$WindowsPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$WindowsPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$WindowsPlatformImpl>
    implements _$$WindowsPlatformImplCopyWith<$Res> {
  __$$WindowsPlatformImplCopyWithImpl(_$WindowsPlatformImpl _value, $Res Function(_$WindowsPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$WindowsPlatformImpl with DiagnosticableTreeMixin implements WindowsPlatform {
  const _$WindowsPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.windows()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.windows'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$WindowsPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return windows();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return windows?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (windows != null) {
      return windows();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return windows(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return windows?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (windows != null) {
      return windows(this);
    }
    return orElse();
  }
}

abstract class WindowsPlatform implements MyPlatform {
  const factory WindowsPlatform() = _$WindowsPlatformImpl;
}

/// @nodoc
abstract class _$$FuchsiaPlatformImplCopyWith<$Res> {
  factory _$$FuchsiaPlatformImplCopyWith(_$FuchsiaPlatformImpl value, $Res Function(_$FuchsiaPlatformImpl) then) =
      __$$FuchsiaPlatformImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FuchsiaPlatformImplCopyWithImpl<$Res> extends _$MyPlatformCopyWithImpl<$Res, _$FuchsiaPlatformImpl>
    implements _$$FuchsiaPlatformImplCopyWith<$Res> {
  __$$FuchsiaPlatformImplCopyWithImpl(_$FuchsiaPlatformImpl _value, $Res Function(_$FuchsiaPlatformImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FuchsiaPlatformImpl with DiagnosticableTreeMixin implements FuchsiaPlatform {
  const _$FuchsiaPlatformImpl();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'MyPlatform.fuchsia()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties.add(DiagnosticsProperty('type', 'MyPlatform.fuchsia'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other.runtimeType == runtimeType && other is _$FuchsiaPlatformImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() android,
    required TResult Function() ios,
    required TResult Function() macos,
    required TResult Function() web,
    required TResult Function() linux,
    required TResult Function() windows,
    required TResult Function() fuchsia,
  }) {
    return fuchsia();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? android,
    TResult? Function()? ios,
    TResult? Function()? macos,
    TResult? Function()? web,
    TResult? Function()? linux,
    TResult? Function()? windows,
    TResult? Function()? fuchsia,
  }) {
    return fuchsia?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? android,
    TResult Function()? ios,
    TResult Function()? macos,
    TResult Function()? web,
    TResult Function()? linux,
    TResult Function()? windows,
    TResult Function()? fuchsia,
    required TResult orElse(),
  }) {
    if (fuchsia != null) {
      return fuchsia();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(AndroidPlatform value) android,
    required TResult Function(IosPlatform value) ios,
    required TResult Function(MacosPlatform value) macos,
    required TResult Function(WebPlatform value) web,
    required TResult Function(LinuxPlatform value) linux,
    required TResult Function(WindowsPlatform value) windows,
    required TResult Function(FuchsiaPlatform value) fuchsia,
  }) {
    return fuchsia(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(AndroidPlatform value)? android,
    TResult? Function(IosPlatform value)? ios,
    TResult? Function(MacosPlatform value)? macos,
    TResult? Function(WebPlatform value)? web,
    TResult? Function(LinuxPlatform value)? linux,
    TResult? Function(WindowsPlatform value)? windows,
    TResult? Function(FuchsiaPlatform value)? fuchsia,
  }) {
    return fuchsia?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(AndroidPlatform value)? android,
    TResult Function(IosPlatform value)? ios,
    TResult Function(MacosPlatform value)? macos,
    TResult Function(WebPlatform value)? web,
    TResult Function(LinuxPlatform value)? linux,
    TResult Function(WindowsPlatform value)? windows,
    TResult Function(FuchsiaPlatform value)? fuchsia,
    required TResult orElse(),
  }) {
    if (fuchsia != null) {
      return fuchsia(this);
    }
    return orElse();
  }
}

abstract class FuchsiaPlatform implements MyPlatform {
  const factory FuchsiaPlatform() = _$FuchsiaPlatformImpl;
}
